package pipeline

import (
	"encoding/json"
	"io"

	log "github.com/sirupsen/logrus"
	"github.com/yurykabanov/scraper/pkg/domain"
)

// TODO: write a note about incomplete json may be generated by this step

type ExporterStage struct {
	input <-chan *domain.ScrapedTask
	w     io.Writer
}

func Exporter(input <-chan *domain.ScrapedTask, w io.Writer) *ExporterStage {
	return &ExporterStage{
		input: input,
		w:     w,
	}
}

var exporterDelimiter = []byte(",")

func (s *ExporterStage) RunStage() {
	enc := json.NewEncoder(s.w)
	isFirst := true

	_, err := s.w.Write([]byte("["))
	if err != nil {
		log.WithError(err).Fatal("Unable to write to file")
	}

	for task := range s.input {
		if !isFirst {
			_, err := s.w.Write(exporterDelimiter)
			if err != nil {
				log.WithError(err).Fatal("Unable to write to file")
			}
		} else {
			isFirst = false
		}

		var data = make(map[string]interface{})
		for k, v := range task.Data {
			data[k] = v
		}

		data["__id__"] = task.Hash()

		data["__meta__"] = map[string]interface{}{
			"status_code":   task.Result.StatusCode,
			"url":           task.Result.Url,
			"task_name_ref": task.TaskRef,
		}

		var refs = make([]string, 0)
		for _, t := range task.NewTasks {
			refs = append(refs, t.Hash())
		}

		data["__refs__"] = refs

		err := enc.Encode(data)
		if err != nil {
			log.WithError(err).Fatal("Unable to serialize/write to file")
		}
	}

	_, err = s.w.Write([]byte("]"))
	if err != nil {
		log.WithError(err).Fatal("Unable to write to file")
	}
}
